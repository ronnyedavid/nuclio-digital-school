# -*- coding: utf-8 -*-
"""Exercise on BMW cars.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19wRAihwkjfGpSMfCRTafhMRKiApj_wM6
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd 
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import LabelEncoder,MinMaxScaler

bmw = pd.read_csv('/content/drive/MyDrive/Entregable1/bmw_pricing_v2.csv')

bmw.head(2)

bmw.info()

bmw[bmw.duplicated(keep=False)]

bmw.isnull().sum()

#Segunda versión del 'dataframe'
bmw2 = bmw.copy()

(bmw2.isnull().sum() / bmw2.shape[0] * 100).sum()

#Eliminación de los nulos de todas las variables
bmw2.dropna(inplace=True)

bmw2.isnull().sum()

bmw2.reset_index(drop=True, inplace=True)

bmw2.info()

#Nueva versión del dataframe
bmw3 = bmw2.copy()

bmw3['fecha_registro'].value_counts()

bmw3['fecha_venta'].value_counts()

del(bmw3['marca'])
del(bmw3['color'])

#Cuarta versión del 'dataframe'
bmw4 = bmw3.copy()

#Cambio de tipo de valor de las variables 'fecha_registro' y 'fecha_venta' a 'datetime'
for i in ["fecha_registro","fecha_venta"]:
    bmw4[i]=pd.to_datetime(bmw4[i])

#Quinta versión
bmw5 = bmw4.copy()

#Separación de los valores de las columnas fecha_registro y fecha_venta
for col in ['fecha_registro', 'fecha_venta']:
    bmw5[col + '_nombreDia'] = bmw5[col].dt.day_name()
    bmw5[col + '_dia'] = bmw5[col].dt.day
    bmw5[col + '_mes'] = bmw5[col].dt.month
    bmw5[col + '_ano'] = bmw5[col].dt.year

bmw5.head()

for b in ('fecha_registro', 'fecha_venta'):
  del(bmw5[b])

#Sexta versión: cambio de algunas categóricas a booleanas

bmw6 = bmw5.copy()

bmw6['volante_regulable'] = bmw6['volante_regulable'].astype('bool')
bmw6['aire_acondicionado'] = bmw6['aire_acondicionado'].astype('bool')
bmw6['camara_trasera'] = bmw6['camara_trasera'].astype('bool')
bmw6['asientos_traseros_plegables'] = bmw6['asientos_traseros_plegables'].astype('bool')
bmw6['elevalunas_electrico'] = bmw6['elevalunas_electrico'].astype('bool')
bmw6['bluetooth'] = bmw6['bluetooth'].astype('bool')
bmw6['alerta_lim_velocidad'] = bmw6['alerta_lim_velocidad'].astype('bool')

bmw6.info()

bmw6['alerta_lim_velocidad'].value_counts()

bmw6['alerta_lim_velocidad'].dtype.kind

bmw6['km'] = bmw6['km'].astype('int')
bmw6['potencia'] = bmw6['potencia'].astype('int')
bmw6['precio'] = bmw6['precio'].astype('int')

bmw6['km'].dtype.kind

bmw6['potencia'].dtype.kind

bmw6['precio'].dtype.kind

#Séptima versión: clasificación de variables, según su tipo
bmw7 = bmw6.copy()

target = ['precio']

def var(dataset):
  numerica=[]
  boolean=[]
  categorica=[]
  for c in dataset:
    if (dataset[c].dtype.kind == 'i' or dataset[c].dtype.kind == 'f') and (c not in target) and \
    (len(dataset[c].unique())!=2):
      numerica.append(c)
    if (dataset[c].dtype.kind == 'b'):
      boolean.append(c)
    if (dataset[c].dtype.kind == 'O' and (c not in target)):
      categorica.append(c)
  return numerica, boolean, categorica

l_num, l_bool, l_cat = var(bmw7)

l_num

l_bool

l_cat

#Revisión variables categóricas
for hc in l_cat:
  print(bmw7[hc].value_counts())

#Revisión variables booleanas
for hc in l_bool:
  print(bmw7[hc].value_counts())

#Revisión variables numéricas
for hn in l_num:
  bmw7.hist(hn)

bmw7.info()

#Octava versión: borrado de negativos de variables numéricas
bmw8 = bmw7.copy()

bmw8.info()

#Revisión variable kilómetro
bmw8[bmw8['km'] < 0]

bmw8[(bmw8['km'] >= 0) & (bmw8['km'] <= 500)]

#Borrado registro negativo de kilómetro
bmw8.drop(bmw8[bmw8['km']<=0].index, inplace=True)

#Comprobación de borrado
bmw8[bmw8['km'] < 0]

#Registro por debajo de los 45000 kilómetros
bmw8[bmw8['km']<=45000].value_counts().sum() / bmw8.shape[0] * 100

bmw8.drop(bmw8[bmw8['km']<=45000].index, inplace=True)

bmw8[(bmw8['km'] >= 250000) & (bmw8['km'] <= 10000000)].value_counts().sum() / bmw8.shape[0] * 100

bmw8.drop(bmw8[bmw8['km'] >= 220000].index, inplace=True)

bmw8.hist('km')

#Comprobación de si hay algún negativo en potencia
bmw8[bmw8['potencia'] <= 0]

#Borrado registro con potencia 0
bmw8.drop(bmw8[bmw8['potencia']<=0].index, inplace=True)

#Comprobación de borrado de potencia 0
bmw8[bmw8['potencia'] <= 0]

bmw8[(bmw8['potencia'] >= 0) & (bmw8['potencia'] <= 100)].value_counts().sum()

#Borrado de registros con potencia iguales e inferiores a 100
bmw8.drop(bmw8[bmw8['potencia']<=100].index, inplace=True)

#Comprobación de registros borrados
bmw8[(bmw8['potencia'] >= 0) & (bmw8['potencia'] <= 100)]

bmw8[(bmw8['potencia'] >= 0) & (bmw8['potencia'] <= 500)].value_counts().sum()

bmw8[(bmw8['potencia'] >= 250) & (bmw8['potencia'] <= 1000)].value_counts().sum() / bmw8.shape[0]*100

bmw8.drop(bmw8[bmw8['potencia'] >= 250].index, inplace=True)

bmw8.hist('potencia')

#Comprobación de valores erróneos en fecha_registro_dia
bmw8[(bmw8['fecha_registro_dia'] <= 0)]

bmw8[(bmw8['fecha_registro_dia'] > 31)]

bmw8.hist('fecha_registro_dia')

bmw8[(bmw8['fecha_registro_dia'] > 2) & (bmw8['fecha_registro_dia'] < 3)]

(bmw8['fecha_registro_dia'] >= 1)

#Comprobación de valores erróneos en fecha_registro_mes
bmw8[(bmw8['fecha_registro_mes'] <= 0)]

bmw8[(bmw8['fecha_registro_mes'] == 13)]

#Comprobación de valores erróneos en fecha_registro_ano
bmw8.hist('fecha_registro_ano')

bmw8[(bmw8['fecha_registro_ano'] <= 1990)]

bmw8[(bmw8['fecha_registro_ano'] >= 2017)]

#Comprobación de valores erróneos en fecha_venta_dia
bmw8[(bmw8['fecha_venta_dia'] <= 0)]

bmw8[(bmw8['fecha_venta_dia'] > 31)]

#Comprobación de valores erróneos en fecha_venta_mes
bmw8[(bmw8['fecha_venta_mes'] <= 0)]

bmw8[(bmw8['fecha_venta_mes'] >= 13)]

bmw8.hist('fecha_venta_mes')

bmw8[(bmw8['fecha_venta_mes'] > 4) & (bmw8['fecha_venta_mes'] < 5)]

bmw8[bmw8['fecha_venta_mes'] == 4].value_counts().sum()

bmw8[bmw8['fecha_venta_mes'] == 5].value_counts().sum()

bmw8[bmw8['fecha_venta_mes'] >= 9].value_counts().sum()

#Comprobación de valores erróneos en fecha_venta_ano
bmw8.hist('fecha_venta_ano')

bmw8[bmw8['fecha_venta_ano'] <= 2007]

bmw8[(bmw8['fecha_venta_ano'] >= 2018)]

bmw8.reset_index(drop=True, inplace=True)

bmw8.info()

#Novena versión: análisis de variables precio
bmw9 = bmw8.copy()

bmw9.hist('precio')

bmw9[bmw9['precio']<=0].value_counts().sum() / bmw9.shape[0]*100

bmw9[bmw9['precio']>=33000].value_counts().sum() / bmw9.shape[0]*100

bmw9[bmw9['precio']<6000].value_counts().sum() / bmw9.shape[0]*100

bmw9[(bmw9['precio']>=0) & (bmw9['precio']<=1000)].value_counts().sum() / bmw9.shape[0]*100

bmw9.drop(bmw9[bmw9['precio']>=33000].index, inplace=True)

bmw9.drop(bmw9[bmw9['precio']<=1000].index, inplace=True)

bmw9.hist('precio')

bmw9.reset_index(drop=True, inplace=True)

bmw9.info()

#Análisis de correlación

bmw10 = bmw9.copy()

bmw10.info()

import seaborn as sb

#Creación de visualización
#Col indica gráfico por día (variable categórica)
#Hue indica el color de los valores, según la variable escogida
#Style indica el tipo de diseño para los puntos, según los valores de la variable escogida
#Size indica el tamaño según la cantidad de la variable
sb.relplot(data=bmw10,
    x='km', y='precio', col='tipo_coche')

sb.relplot(data=bmw10,
    x='potencia', y='precio', col='tipo_coche')

sb.relplot(data=bmw10,
    x='km', y='precio', col='tipo_gasolina')

sb.relplot(data=bmw10,
    x='potencia', y='precio', col='tipo_gasolina')

corr = bmw10.corr()

corr.style.background_gradient(cmap = 'coolwarm')

bmw10.info()

#Undécima versión: escalado de variables

bmw11 = bmw10.copy()

bmw11 = pd.get_dummies(data=bmw11, columns=l_cat)

corr2 = bmw11.corr()

corr2.style.background_gradient(cmap = 'coolwarm')