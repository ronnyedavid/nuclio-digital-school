# -*- coding: utf-8 -*-
"""Exercise on BMW cars update_26th Nov 2022.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FK_zl2kIJr_pBu8e-g2BAMu71okvP-87
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd 
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sb
from sklearn.preprocessing import LabelEncoder,MinMaxScaler

bmw = pd.read_csv('/content/drive/MyDrive/Entregable1/bmw_pricing_v2.csv')

bmw.head(2)

bmw.info()

bmw[bmw.duplicated(keep=False)]

bmw.isnull().sum()

#Segunda versión del 'dataframe'
bmw2 = bmw.copy()

(bmw2.isnull().sum() / bmw2.shape[0] * 100).sum()

#Eliminación de los nulos de la mayoría de las variables, exceptuando la de precio,
#cuyos valores nulos se han sustituido por la mediana,
#al ser una medida que elimina los sesgos en cuanto a encontrar la tendencia central
bmw2['precio'].isnull().sum()

media = bmw2['precio'].mean()

mediana = bmw2['precio'].median()

bmw2['precio'].fillna(mediana, inplace=True)

bmw2['precio'].isnull().sum()

bmw2.dropna(inplace=True)

bmw2.isnull().sum()

bmw2.reset_index(drop=True, inplace=True)

bmw2.info()

#Nueva versión del dataframe
bmw3 = bmw2.copy()

bmw3['fecha_registro'].value_counts()

bmw3['fecha_venta'].value_counts()

del(bmw3['marca'])
del(bmw3['color'])

#Cuarta versión del 'dataframe'
bmw4 = bmw3.copy()

#Separación de los valores de las columnas fecha_registro y fecha_venta
for i in ["fecha_registro","fecha_venta"]:
    bmw4[i]=pd.to_datetime(bmw4[i])

#Separación de los valores de las columnas fecha_registro y fecha_venta
for col in ['fecha_registro', 'fecha_venta']:
    bmw4[col + '_dia'] = bmw4[col].dt.day
    bmw4[col + '_mes'] = bmw4[col].dt.month
    bmw4[col + '_ano'] = bmw4[col].dt.year

bmw4.head(3)

#Quinta versión
bmw5 = bmw4.copy()

for b in ('fecha_registro', 'fecha_venta'):
  del(bmw5[b])

#Sexta versión: cambio de algunas categóricas a booleanas

bmw6 = bmw5.copy()

bmw6['volante_regulable'] = bmw6['volante_regulable'].astype('bool')
bmw6['aire_acondicionado'] = bmw6['aire_acondicionado'].astype('bool')
bmw6['camara_trasera'] = bmw6['camara_trasera'].astype('bool')
bmw6['asientos_traseros_plegables'] = bmw6['asientos_traseros_plegables'].astype('bool')
bmw6['elevalunas_electrico'] = bmw6['elevalunas_electrico'].astype('bool')
bmw6['bluetooth'] = bmw6['bluetooth'].astype('bool')
bmw6['alerta_lim_velocidad'] = bmw6['alerta_lim_velocidad'].astype('bool')

bmw6.info()

bmw6['alerta_lim_velocidad'].value_counts()

bmw6['alerta_lim_velocidad'].dtype.kind

bmw6['km'] = bmw6['km'].astype('int')
bmw6['potencia'] = bmw6['potencia'].astype('int')
bmw6['precio'] = bmw6['precio'].astype('int')

bmw6['km'].dtype.kind

bmw6['potencia'].dtype.kind

bmw6['precio'].dtype.kind

#Séptima versión: clasificación de variables, según su tipo
bmw7 = bmw6.copy()

target = ['precio']

def var(dataset):
  numerica=[]
  boolean=[]
  categorica=[]
  for c in dataset:
    if (dataset[c].dtype.kind == 'i' or dataset[c].dtype.kind == 'f') and (c not in target) and \
    (len(dataset[c].unique())!=2):
      numerica.append(c)
    if (dataset[c].dtype.kind == 'b'):
      boolean.append(c)
    if (dataset[c].dtype.kind == 'O' and (c not in target)):
      categorica.append(c)
  return numerica, boolean, categorica

l_num, l_bool, l_cat = var(bmw7)

l_num

l_bool

l_cat

#Revisión variables categóricas
for hc in l_cat:
  print(bmw7[hc].value_counts())

#Revisión variables booleanas
for hc in l_bool:
  print(bmw7[hc].value_counts())

#Revisión variables numéricas
for hn in l_num:
  bmw7.hist(hn)

bmw7.info()

#Octava versión: borrado de negativos de variables numéricas
bmw8 = bmw7.copy()

bmw8.info()

#Revisión variable kilómetro
bmw8[bmw8['km'] < 0]

bmw8[(bmw8['km'] >= 0) & (bmw8['km'] <= 500)]

#Borrado registro negativo de kilómetro
bmw8.drop(bmw8[bmw8['km']<=0].index, inplace=True)

#Comprobación de borrado
bmw8[bmw8['km'] < 0]

#Registro por debajo de los 45000 kilómetros
bmw8[bmw8['km']<=45000].value_counts().sum() / bmw8.shape[0] * 100

bmw8.drop(bmw8[bmw8['km']<=45000].index, inplace=True)

bmw8[(bmw8['km'] >= 250000) & (bmw8['km'] <= 10000000)].value_counts().sum() / bmw8.shape[0] * 100

bmw8.drop(bmw8[bmw8['km'] >= 220000].index, inplace=True)

bmw8.hist('km')

#Comprobación de si hay algún negativo en potencia
bmw8[bmw8['potencia'] <= 0]

#Borrado registro con potencia 0
bmw8.drop(bmw8[bmw8['potencia']<=0].index, inplace=True)

#Comprobación de borrado de potencia 0
bmw8[bmw8['potencia'] <= 0]

bmw8[(bmw8['potencia'] >= 0) & (bmw8['potencia'] <= 100)].value_counts().sum()

#Borrado de registros con potencia iguales e inferiores a 100
bmw8.drop(bmw8[bmw8['potencia']<=100].index, inplace=True)

#Comprobación de registros borrados
bmw8[(bmw8['potencia'] >= 0) & (bmw8['potencia'] <= 100)]

bmw8[(bmw8['potencia'] >= 0) & (bmw8['potencia'] <= 500)].value_counts().sum()

bmw8[(bmw8['potencia'] >= 250) & (bmw8['potencia'] <= 1000)].value_counts().sum() / bmw8.shape[0]*100

bmw8.drop(bmw8[bmw8['potencia'] >= 250].index, inplace=True)

bmw8.hist('potencia')

#Comprobación de valores erróneos en fecha_registro_dia
bmw8[(bmw8['fecha_registro_dia'] <= 0)]

bmw8[(bmw8['fecha_registro_dia'] > 31)]

bmw8.hist('fecha_registro_dia')

bmw8[(bmw8['fecha_registro_dia'] > 2) & (bmw8['fecha_registro_dia'] < 3)]

(bmw8['fecha_registro_dia'] >= 1)

#Comprobación de valores erróneos en fecha_registro_mes
bmw8[(bmw8['fecha_registro_mes'] <= 0)]

bmw8[(bmw8['fecha_registro_mes'] == 13)]

#Comprobación de valores erróneos en fecha_registro_ano
bmw8.hist('fecha_registro_ano')

bmw8[(bmw8['fecha_registro_ano'] <= 1990)]

bmw8[(bmw8['fecha_registro_ano'] >= 2017)]

#Comprobación de valores erróneos en fecha_venta_dia
bmw8[(bmw8['fecha_venta_dia'] <= 0)]

bmw8[(bmw8['fecha_venta_dia'] > 31)]

#Comprobación de valores erróneos en fecha_venta_mes
bmw8[(bmw8['fecha_venta_mes'] <= 0)]

bmw8[(bmw8['fecha_venta_mes'] >= 13)]

bmw8.hist('fecha_venta_mes')

bmw8[(bmw8['fecha_venta_mes'] > 4) & (bmw8['fecha_venta_mes'] < 5)]

bmw8[bmw8['fecha_venta_mes'] == 4].value_counts().sum()

bmw8[bmw8['fecha_venta_mes'] == 5].value_counts().sum()

bmw8[bmw8['fecha_venta_mes'] >= 9].value_counts().sum()

#Comprobación de valores erróneos en fecha_venta_ano
bmw8.hist('fecha_venta_ano')

bmw8[bmw8['fecha_venta_ano'] <= 2007]

bmw8[(bmw8['fecha_venta_ano'] >= 2018)]

#Revisión variables categóricas
bmw8['modelo'].value_counts()

bmw8['tipo_gasolina'].value_counts()

bmw8[bmw8['tipo_gasolina']=='Diesel']

#Reemplazo de valores Diesel por diesel. Así se normalizaba este tipo de gasolina
bmw8.replace(to_replace=r'Diesel', value='diesel', regex=True, inplace=True)

bmw8['tipo_gasolina'].value_counts()

bmw8['tipo_coche'].value_counts()

bmw8.reset_index(drop=True, inplace=True)

bmw8.info()

#Novena versión: análisis de variables precio
bmw9 = bmw8.copy()

bmw9.hist('precio')

bmw9[bmw9['precio']<=0].value_counts().sum() / bmw9.shape[0]*100

bmw9[bmw9['precio']>=33000].value_counts().sum() / bmw9.shape[0]*100

bmw9[bmw9['precio']<6000].value_counts().sum() / bmw9.shape[0]*100

bmw9[(bmw9['precio']>=0) & (bmw9['precio']<=1000)].value_counts().sum() / bmw9.shape[0]*100

bmw9.drop(bmw9[bmw9['precio']>=33000].index, inplace=True)

bmw9.drop(bmw9[bmw9['precio']<=1000].index, inplace=True)

bmw9.hist('precio')

bmw9.reset_index(drop=True, inplace=True)

bmw9.info()

#Análisis de correlación

bmw10 = bmw9.copy()

bmw10.info()

#Visualización de relaciones entre variables numéricas y precio (target)

sb.lmplot(data=bmw10,
    x='km', y='precio')

sb.regplot(data=bmw10,
    x='potencia', y='precio')

#Relación variable tipo_coche y precio
sb.violinplot(x='tipo_coche', y='precio', data=bmw10)

sb.violinplot(x='tipo_gasolina', y='precio', data=bmw10)

sb.violinplot(x='volante_regulable', y='precio', data=bmw10)

sb.violinplot(x='alerta_lim_velocidad', y='precio', data=bmw10)

bmw10.info()

#Correlación antes de creación de variables variables a partir de variables categóricas (tipo_gasolina, tipo_coche, modelo)
corr = bmw10.corr()

corr.style.background_gradient(cmap = 'coolwarm')

bmw10.info()

#Undécima versión: reescalado de variables

bmw11 = bmw10.copy()

bmw11 = pd.get_dummies(data=bmw11, columns=l_cat)

corr2 = bmw11.corr()

corr2.style.background_gradient(cmap = 'coolwarm')

#Reescalado de valores de variables
minMaxResult = MinMaxScaler()

bmw12 = bmw11.copy()

bmw12['km'] = minMaxResult.fit_transform(bmw12['km'].values.reshape(-1,1))

bmw12['potencia'] = minMaxResult.fit_transform(bmw12['potencia'].values.reshape(-1,1))